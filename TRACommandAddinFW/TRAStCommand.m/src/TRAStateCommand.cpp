// COPYRIGHT Dassault Systemes 2022
//===================================================================
//
// TRAStateCommand.cpp
// The state chart based command: TRAStateCommand
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Jun 2022  Creation: Code generated by the CAA wizard  Dell
//===================================================================
#include "TRAStateCommand.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"
#include "CATFrmEditor.h"
#include "CATDocument.h"
#include "CATIDocRoots.h"
#include "CATIProduct.h"
#include "CATDocumentServices.h"
#include "CATIMovable.h"
#include "CATIModelEvents.h"
#include "CATModify.h"
#include "CATIRedrawEvent.h"
#include "CATBaseUnknown.h"
#include "CATILinkableObject.h"
#include "CATMmrInterPartCopy.h"
#include "CATIContainerOfDocument.h"
#include "CATIPrtContainer.h"
#include "CATIPartRequest.h"
#include "CATIDescendants.h"












#include<iostream>
using namespace std;




CATCreateClass( TRAStateCommand);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
TRAStateCommand::TRAStateCommand() :
  CATStateCommand ("TRAStateCommand", CATDlgEngOneShot, CATCommandModeExclusive) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
  
{

	_spRootProduct = NULL_var;
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
TRAStateCommand::~TRAStateCommand()
{
   
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void TRAStateCommand::BuildGraph()
{

	CATFrmEditor * pEditor = NULL;

	pEditor = CATFrmEditor::GetCurrentEditor();
	if(!!pEditor)
	{
		CATDocument *  pDocument = pEditor->GetDocument();
		if(!!pDocument)
		{
			std::cout<<"doc is received" <<std::endl;
		}

	

	CATIDocRoots *piDocRootsOnDoc = NULL;
	HRESULT rc = pDocument->QueryInterface(IID_CATIDocRoots,
		                      (void**) &piDocRootsOnDoc);

	CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();

	std::cout << std::endl << " RootProducts List created " << std::endl ;	

	_spRootProduct = (*pRootProducts)[1];
			delete pRootProducts;
			pRootProducts = NULL;
	CATIProduct *piProductOnRoot = NULL;
	rc = _spRootProduct->QueryInterface(IID_CATIProduct,
		                               (void**) &piProductOnRoot);

	std::cout << std::endl << " Got the Root Product " << std::endl ;


	 //
  // 3-2 The components of the root product
  // 
  CATListValCATBaseUnknown_var * pListDirectChildren = piProductOnRoot->GetChildren(); 
  

  piProductOnRoot->Release();
  piProductOnRoot = NULL ;

  // Comp1 and Comp2
  CATIProduct_var spComp1 = (*pListDirectChildren)[1] ;
  CATIProduct_var spComp2 = (*pListDirectChildren)[2] ;


   // The component of Comp2
  pListDirectChildren = spComp2->GetChildren(); 
  

  // Comp3
  CATIProduct_var spComp3 = (*pListDirectChildren)[1] ;

 

  delete pListDirectChildren ;
  pListDirectChildren = NULL ;

  // The Part feature
  CATISpecObject_var spSpecObjectOnMechPartOfComp3  ;
  rc = CAAMmrGetPartFromProduct(spComp3, spSpecObjectOnMechPartOfComp3);

   // The PartBody feature
  CATBaseUnknown * pBody = NULL ;
  rc = CAAMmrGetGeometry(spSpecObjectOnMechPartOfComp3,"PartBody",&pBody);

  CATBaseUnknown_var spOnBodyOfComp3 = pBody ;
  pBody->Release();
  pBody = NULL ;

   // The Part feature
  CATISpecObject_var spSpecObjectOnMechPartOfComp1  ;
  rc = CAAMmrGetPartFromProduct(spComp1,spSpecObjectOnMechPartOfComp1);

   // The PartBody feature
  pBody = NULL ;
  rc = CAAMmrGetGeometry(spSpecObjectOnMechPartOfComp1,"PartBody",&pBody);
  

  CATBaseUnknown_var spOnBodyOfComp1 = pBody ;
  pBody->Release();
  pBody = NULL ;

   CATMmrInterPartCopy * ptCATMmrInterPartCopy = NULL ;

  CATISpecObject_var SourceToCopy = spOnBodyOfComp3 ;
  CATISpecObject_var Target       = spSpecObjectOnMechPartOfComp1 ;

  ptCATMmrInterPartCopy =  new CATMmrInterPartCopy (SourceToCopy,Target) ;
                                                    
                                                    
 
     ptCATMmrInterPartCopy ->SetSourceInstance(spComp3);
     ptCATMmrInterPartCopy ->SetTargetInstance(spComp1);

	 CATBoolean CopyWithLink = TRUE ;
 

  // Sets the option of copy 
  ptCATMmrInterPartCopy ->SetLinkMode(CopyWithLink) ; 
  
  // Executes the copy
  CATUnicodeString ErrorMsg ;
  rc = ptCATMmrInterPartCopy ->Run(&ErrorMsg);
 
 

  // Retrieves the result
  CATISpecObject_var Result ;
  rc = ptCATMmrInterPartCopy ->GetResult(Result);
  if ( SUCCEEDED(rc) && (NULL_var != Result) )
  {
      CATIAlias_var alias = Result  ;
     
  }


  delete ptCATMmrInterPartCopy ;
  ptCATMmrInterPartCopy = NULL ;

  }

  }


  HRESULT TRAStateCommand::CAAMmrGetPartFromProduct(CATIProduct_var       ispProduct,                                
	  CATISpecObject_var  & ospPartFromProduct)
  {

	  HRESULT rc = E_FAIL ;



	  CATIProduct_var spRef = ispProduct->GetReferenceProduct();

	  if ( NULL_var != spRef )
	  {
		  CATILinkableObject * piLinkableObject = NULL;
		  rc = spRef->QueryInterface( IID_CATILinkableObject, (void**)& piLinkableObject );                            

		  if ( SUCCEEDED(rc) )
		  {
			  // Do not release this pointer
			  CATDocument * pDocument = NULL ;
			  pDocument = piLinkableObject->GetDocument();

			  if ( NULL != pDocument )
			  {
				  CATIContainerOfDocument * pIContainerOfDocument = NULL ;
				  rc = pDocument->QueryInterface(IID_CATIContainerOfDocument, 
					  (void**)& pIContainerOfDocument );
				  if ( SUCCEEDED(rc) )
				  {
					  CATIContainer * pIContainerOnSpecContainer = NULL ;
					  rc = pIContainerOfDocument->GetSpecContainer(pIContainerOnSpecContainer);
					  if ( SUCCEEDED(rc) && (NULL!=pIContainerOnSpecContainer) )
					  {
						  CATIPrtContainer * piPrtCont = NULL ;
						  rc = pIContainerOnSpecContainer->QueryInterface( IID_CATIPrtContainer , 
							  (void**) &piPrtCont );

						  if ( SUCCEEDED(rc) )
						  {
							  ospPartFromProduct = piPrtCont->GetPart();

							  piPrtCont->Release();
							  piPrtCont =  NULL ;
						  }
						  pIContainerOnSpecContainer->Release();
						  pIContainerOnSpecContainer = NULL ;
					  }
					  pIContainerOfDocument->Release();
					  pIContainerOfDocument = NULL ;
				  }
			  } else rc = E_FAIL ;

			  piLinkableObject->Release();
			  piLinkableObject = NULL ;
		  }
	  }

	  return rc ;

  }

  




  HRESULT TRAStateCommand::CAAMmrGetGeometry(CATISpecObject_var ispModelPart, const CATUnicodeString iInputName,
	  CATBaseUnknown ** oInput)
  {

	  HRESULT rc = E_FAIL ;
	  CATBoolean found = FALSE ;	

	  if ( (NULL != oInput) && ( NULL_var != ispModelPart) )
	  {   
		  *oInput = NULL ;

		  CATIPartRequest * pPartAsRequest = NULL ;
		  rc = ispModelPart->QueryInterface(IID_CATIPartRequest,(void**)&pPartAsRequest);
		  if ( SUCCEEDED(rc) )
		  {
			  // Retrieves all bodies
			  CATListValCATBaseUnknown_var pListBodies  ;
			  rc = pPartAsRequest->GetAllBodies("",pListBodies);
			  if ( SUCCEEDED(rc) )
			  {
				  int iBodies =1 ;	  
				  int nbbodies = pListBodies.Size();

				  while ( (FALSE == found) && (iBodies <= nbbodies) )
				  {
					  CATIAlias_var spAliasBody = pListBodies[iBodies] ;
					  if ( NULL_var != spAliasBody )
					  {
						  CATUnicodeString currentbodyname = spAliasBody->GetAlias();

						  if ( iInputName == currentbodyname )
						  {
							  // We have found a body
							  found = TRUE ;
							  rc = spAliasBody->QueryInterface(IID_CATBaseUnknown,(void**)&(*oInput));
						  }
						  else
						  {

							  // Research in the body
							  CATIDescendants * pIDescendants = NULL ;
							  rc =  spAliasBody->QueryInterface(IID_CATIDescendants,(void**)&pIDescendants);
							  if ( SUCCEEDED(rc) )
							  {
								  // finds a specific element in the body
								  int iChild=1 ;	  
								  int nbchild = pIDescendants->GetNumberOfChildren() ;

								  while (  (FALSE == found) && (iChild <= nbchild) )
								  {
									  CATIAlias_var spChild = pIDescendants->GetChildAtPosition(iChild) ;
									  if ( NULL_var != spChild )
									  {
										  CATUnicodeString currentchildname = spChild->GetAlias();

										  if ( iInputName == currentchildname )
										  {
											  // we have found a child of a body
											  found = TRUE ;
											  rc = spChild->QueryInterface(IID_CATBaseUnknown,(void**)&(*oInput));
										  }
									  }
									  iChild++ ;
								  }

								  pIDescendants->Release();
								  pIDescendants = NULL ;
							  }
						  }
					  }
					  iBodies ++ ;               
				  }
			  }
		  }


		  
	  }

	  return rc ;

  }



 









void TRAStateCommand::RefreshVisuAndTree(CATBaseUnknown_var spUnknown)
{
	CATIModelEvents_var spEvents = spUnknown;

	CATModify ntfModify(spUnknown);

	spEvents->Dispatch(ntfModify);

	CATIRedrawEvent_var spRedraw = spUnknown;

	spRedraw->Redraw();
}